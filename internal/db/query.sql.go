// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getVideoByID = `-- name: GetVideoByID :one
SELECT
  v.name,
  v.poster,
  v.source,
  vm.likes,
  vm.views,
  vm.shares,
  c.channel_id,
  c.name AS channel_name,
  c.pic AS channel_pic,
  v.created_at,
  COALESCE(
    array_agg (DISTINCT cat.category) FILTER (
      WHERE
        cat.category IS NOT NULL
    ),
    '{}'
  ) AS categories,
  COALESCE(
    array_agg (DISTINCT t.name) FILTER (
      WHERE
        t.name IS NOT NULL
    ),
    '{}'
  ) AS tags,
  COALESCE(
    array_agg (DISTINCT a.name) FILTER (
      WHERE
        a.name IS NOT NULL
    ),
    '{}'
  ) AS actors
FROM
  videos v
  INNER JOIN video_metadata vm ON v.video_metadata = vm.id
  INNER JOIN channels c ON v.posted_by = c.id
  LEFT JOIN video_categories vc ON vc.video_id = v.id
  LEFT JOIN categories cat ON cat.id = vc.category_id
  LEFT JOIN video_tags vt ON vt.video_id = v.id
  LEFT JOIN tags t ON t.id = vt.tag_id
  LEFT JOIN video_actors va ON va.video_id = v.id
  LEFT JOIN actors a ON a.id = va.actor_id
WHERE
  v.video_id = $1
GROUP BY
  v.id,
  vm.likes,
  vm.views,
  vm.shares,
  c.channel_id,
  c.name,
  c.pic,
  v.created_at
`

type GetVideoByIDRow struct {
	Name        string
	Poster      string
	Source      string
	Likes       pgtype.Int8
	Views       pgtype.Int8
	Shares      pgtype.Int8
	ChannelID   pgtype.UUID
	ChannelName string
	ChannelPic  pgtype.Text
	CreatedAt   pgtype.Timestamptz
	Categories  []string
	Tags        []string
	Actors      []string
}

func (q *Queries) GetVideoByID(ctx context.Context, videoID pgtype.UUID) (GetVideoByIDRow, error) {
	row := q.db.QueryRow(ctx, getVideoByID, videoID)
	var i GetVideoByIDRow
	err := row.Scan(
		&i.Name,
		&i.Poster,
		&i.Source,
		&i.Likes,
		&i.Views,
		&i.Shares,
		&i.ChannelID,
		&i.ChannelName,
		&i.ChannelPic,
		&i.CreatedAt,
		&i.Categories,
		&i.Tags,
		&i.Actors,
	)
	return i, err
}

const getVideosForHome = `-- name: GetVideosForHome :many
SELECT
  v.video_id,
  v.name,
  v.poster,
  v.source,
  vm.likes,
  c.channel_id,
  c.name,
  c.pic,
  v.created_at
FROM
  videos v
  INNER JOIN video_metadata vm ON v.video_metadata = vm.id
  INNER JOIN channels c ON v.posted_by = c.id
LIMIT
  $1
OFFSET
  $2
`

type GetVideosForHomeParams struct {
	Limit  int64
	Offset int64
}

type GetVideosForHomeRow struct {
	VideoID   pgtype.UUID
	Name      string
	Poster    string
	Source    string
	Likes     pgtype.Int8
	ChannelID pgtype.UUID
	Name_2    string
	Pic       pgtype.Text
	CreatedAt pgtype.Timestamptz
}

// Videos
func (q *Queries) GetAllVideo(ctx context.Context, arg GetVideosForHomeParams) ([]GetVideosForHomeRow, error) {
	rows, err := q.db.Query(ctx, getVideosForHome, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVideosForHomeRow
	for rows.Next() {
		var i GetVideosForHomeRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Name,
			&i.Poster,
			&i.Source,
			&i.Likes,
			&i.ChannelID,
			&i.Name_2,
			&i.Pic,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newVideo = `-- name: NewVideo :exec
WITH metadata AS (
  INSERT INTO video_metadata (video_metadata_id) 
  VALUES (gen_random_uuid())
  RETURNING id
)
INSERT INTO videos (
  video_id,
  "name",
  "description",
  source,
  poster,
  posted_by,
  video_metadata
) VALUES (
  gen_random_uuid(),
  $1,
  $2,
  $3,
  $4,
  $5,
  (SELECT id FROM metadata)
)
`

type NewVideoParams struct {
	Name        string
	Description pgtype.Text
	Source      string
	Poster      string
	PostedBy    int64
}

func (q *Queries) NewVideo(ctx context.Context, arg NewVideoParams) error {
	_, err := q.db.Exec(ctx, newVideo,
		arg.Name,
		arg.Description,
		arg.Source,
		arg.Poster,
		arg.PostedBy,
	)
	return err
}
